<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>spaghetti.network &#8212; spaghetti v1.3.1 Manual</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pysal-styles.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          spaghetti</a>
        <span class="navbar-text navbar-version pull-left"><b>1.3.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-with-conda-via-spaghetti-feedstock-highly-recommended">Installing with <code class="docutils literal notranslate"><span class="pre">conda</span></code> via spaghetti-feedstock (highly recommended)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-with-python-package-index">Installing with Python Package Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#development-version">Development Version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#spaghetti-network">spaghetti.Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#spaghetti-pointpattern">spaghetti.PointPattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#spaghetti-simulatedpointpattern">spaghetti.SimulatedPointPattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#spaghetti">spaghetti</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for spaghetti.network</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.analysis</span> <span class="k">import</span> <span class="n">NetworkG</span><span class="p">,</span> <span class="n">NetworkK</span><span class="p">,</span> <span class="n">NetworkF</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">libpysal</span> <span class="k">import</span> <span class="n">cg</span><span class="p">,</span> <span class="n">examples</span><span class="p">,</span> <span class="n">weights</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">libpysal</span> <span class="k">import</span> <span class="nb">open</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">libpysal</span>

    <span class="nb">open</span> <span class="o">=</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Network&quot;</span><span class="p">,</span> <span class="s2">&quot;PointPattern&quot;</span><span class="p">,</span> <span class="s2">&quot;NetworkG&quot;</span><span class="p">,</span> <span class="s2">&quot;NetworkK&quot;</span><span class="p">,</span> <span class="s2">&quot;NetworkF&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Network</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Spatially-constrained network representation and analytical</span>
<span class="sd">    functionality. Naming conventions are as follows, (1) arcs and</span>
<span class="sd">    vertices for the full network object, and (2) edges and nodes for</span>
<span class="sd">    the simplified graph-theoretic object. The term &#39;link&#39; is used to</span>
<span class="sd">    refer to a network arc or a graph edge.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    in_data : {geopandas.GeoDataFrame, str}</span>
<span class="sd">        The input geographic data. Either (1) a path to a shapefile</span>
<span class="sd">        (str); or (2) a `geopandas.GeoDataFrame </span>
<span class="sd">        &lt;http://geopandas.org/data_structures.html#geodataframe&gt;`_.</span>
<span class="sd">    </span>
<span class="sd">    vertex_sig : int</span>
<span class="sd">        Round the x and y coordinates of all vertices to ``vertex_sig``</span>
<span class="sd">        significant digits (combined significant digits on the left and</span>
<span class="sd">        right of the decimal place). Default is 11. Set to ``None`` for</span>
<span class="sd">        no rounding.</span>
<span class="sd">    </span>
<span class="sd">    unique_arcs : bool</span>
<span class="sd">        If ``True`` (default), keep only unique arcs (i.e., prune</span>
<span class="sd">        out any duplicated arcs). If ``False`` keep all segments.</span>
<span class="sd">    </span>
<span class="sd">    extractgraph : bool</span>
<span class="sd">        If ``True``, extract a graph-theoretic object with no degree 2</span>
<span class="sd">        nodes. Default is ``True``.</span>
<span class="sd">    </span>
<span class="sd">    w_components : bool</span>
<span class="sd">        Set to ``False`` to not record connected components from a</span>
<span class="sd">        `libpysal.weights.weights.W </span>
<span class="sd">        &lt;https://libpysal.readthedocs.io/en/latest/generated/</span>
<span class="sd">        libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">        object. Default is True.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    weightings : {dict, bool}</span>
<span class="sd">        If ``dict``, lists of weightings for each arc. If ``bool``,</span>
<span class="sd">        ``True`` flags ``self.arc_lengths`` as the weightings,</span>
<span class="sd">        ``False`` sets to no weightings. Default is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    adjacencylist : list</span>
<span class="sd">        List of lists storing vertex adjacency.</span>
<span class="sd">    </span>
<span class="sd">    vertex_coords : dict</span>
<span class="sd">        Keys are the vertex ID and values are the (x,y) coordinates</span>
<span class="sd">        inverse to vertices.</span>
<span class="sd">    </span>
<span class="sd">    vertex_list : list</span>
<span class="sd">        List of vertex IDs.</span>
<span class="sd">    </span>
<span class="sd">    vertices : dict</span>
<span class="sd">        Keys are tuples of vertex coords and values are the vertex ID.</span>
<span class="sd">    </span>
<span class="sd">    arcs : list</span>
<span class="sd">        List of arcs, where each arc is a sorted tuple</span>
<span class="sd">        of vertex IDs.</span>
<span class="sd">    </span>
<span class="sd">    arc_lengths : dict</span>
<span class="sd">        Keys are tuples of sorted vertex IDs representing an arc and</span>
<span class="sd">        values are the length.</span>
<span class="sd">    </span>
<span class="sd">    pointpatterns : dict</span>
<span class="sd">        Keys are a string name of the pattern and values are</span>
<span class="sd">        ``PointPattern`` class instances.</span>
<span class="sd">    </span>
<span class="sd">    alldistances : dict</span>
<span class="sd">        Keys are the vertex IDs (``int``). Values are tuples with two</span>
<span class="sd">        elements as follows (1) a list of the shortest path distances;</span>
<span class="sd">        (2) a dict with the key being the id of the destination vertex</span>
<span class="sd">        and the value being a list of the shortest path.</span>
<span class="sd">    </span>
<span class="sd">    distancematrix : `numpy.ndarray &lt;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">        all network vertices (non-observations) distance matrix.</span>
<span class="sd">    </span>
<span class="sd">    edges : list</span>
<span class="sd">        tuples of graph edge ids.</span>
<span class="sd">    </span>
<span class="sd">    edge_lengths : dict</span>
<span class="sd">        Keys are the graph edge ids (tuple). Values are the graph edge</span>
<span class="sd">        length (``float``).</span>
<span class="sd">    </span>
<span class="sd">    non_articulation_points : list</span>
<span class="sd">        All vertices with degree 2 that are not in an isolated</span>
<span class="sd">        island ring (loop) component</span>
<span class="sd">    </span>
<span class="sd">    w_network : `libpysal.weights.weights.W &lt;https://libpysal.readthedocs.io/en/latest/generated/libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">        Weights object created from the network arcs</span>
<span class="sd">    </span>
<span class="sd">    network_n_components : int</span>
<span class="sd">        Count of connected components in the network.</span>
<span class="sd">    </span>
<span class="sd">    network_component_labels : `numpy.ndarray &lt;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">        Component labels for networks arc</span>
<span class="sd">    </span>
<span class="sd">    network_component2arc : dict</span>
<span class="sd">        Lookup ``{int: list}`` for arcs comprising network</span>
<span class="sd">        connected components keyed by component labels with arcs in</span>
<span class="sd">        a ``list`` as values.</span>
<span class="sd">    </span>
<span class="sd">    network_component_is_ring : dict</span>
<span class="sd">        Lookup ``{int: bool}`` keyed by component labels with values</span>
<span class="sd">        as ``True`` if the component is a closed ring, otherwise</span>
<span class="sd">        ``False``.</span>
<span class="sd">    </span>
<span class="sd">    w_graph : `libpysal.weights.weights.W &lt;https://libpysal.readthedocs.io/en/latest/generated/libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">        Weights object created from the graph edges</span>
<span class="sd">    </span>
<span class="sd">    graph_n_components : int</span>
<span class="sd">        Count of connected components in the network.</span>
<span class="sd">    </span>
<span class="sd">    graph_component_labels : `numpy.ndarray &lt;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">        Component labels for graph edges</span>
<span class="sd">    </span>
<span class="sd">    graph_component2edge : dict</span>
<span class="sd">        Lookup ``{int: list}`` for edges comprising graph connected</span>
<span class="sd">        components keyed by component labels with edges in a list</span>
<span class="sd">        as values.</span>
<span class="sd">    </span>
<span class="sd">    graph_component_is_ring : dict</span>
<span class="sd">        Lookup ``{int: bool}`` keyed by component labels with values as</span>
<span class="sd">        ``True`` if the component is a closed ring, otherwise ``False``.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Instantiate an instance of a network.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">    &gt;&gt;&gt; streets_file = examples.get_path(&#39;streets.shp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ntw = spgh.Network(in_data=streets_file)</span>
<span class="sd">    </span>
<span class="sd">    Snap point observations to the network with attribute information.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; crimes_file = examples.get_path(&#39;crimes.shp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ntw.snapobservations(crimes_file, &#39;crimes&#39;, attribute=True)</span>
<span class="sd">   </span>
<span class="sd">    And without attribute information.</span>
<span class="sd">   </span>
<span class="sd">    &gt;&gt;&gt; schools_file = examples.get_path(&#39;schools.shp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ntw.snapobservations(schools_file, &#39;schools&#39;, attribute=False)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">in_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vertex_sig</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
        <span class="n">unique_arcs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">extractgraph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">w_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weightings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># do this when creating a clean network instance from a</span>
        <span class="c1"># shapefile or a geopandas.GeoDataFrame, otherwise a shell</span>
        <span class="c1"># network instance is created (see `split_arcs()` method)</span>
        <span class="k">if</span> <span class="n">in_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># set parameters as attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="n">in_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_sig</span> <span class="o">=</span> <span class="n">vertex_sig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_arcs</span> <span class="o">=</span> <span class="n">unique_arcs</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># initialize network arcs and arc_lengths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># initialize pointpatterns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># spatial representation of the network</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extractnetwork</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

            <span class="c1"># extract connected components</span>
            <span class="k">if</span> <span class="n">w_components</span><span class="p">:</span>
                <span class="n">as_graph</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">network_weightings</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">weightings</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># set network arc weights to length if weights are</span>
                    <span class="c1"># desired, but no other input in given</span>
                    <span class="n">weightings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span>
                    <span class="n">network_weightings</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># extract contiguity weights from libpysal</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span>
                <span class="p">)</span>
                <span class="c1"># extract connected components from the `w_network`</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extract_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_network</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">)</span>

            <span class="c1"># extract the graph -- repeat similar as above</span>
            <span class="c1"># for extracting the network</span>
            <span class="k">if</span> <span class="n">extractgraph</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extractgraph</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">w_components</span><span class="p">:</span>
                    <span class="n">as_graph</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">network_weightings</span><span class="p">:</span>
                        <span class="n">weightings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">w_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span>
                        <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extract_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_graph</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">)</span>

            <span class="c1"># sorted list of vertex ids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<div class="viewcode-block" id="Network._round_sig"><a class="viewcode-back" href="../../generated/spaghetti.Network._round_sig.html#spaghetti.Network._round_sig">[docs]</a>    <span class="k">def</span> <span class="nf">_round_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used internally to round the vertex to a set number of</span>
<span class="sd">        significant digits. If ``sig`` is set to 4, then the following</span>
<span class="sd">        are some possible results for a coordinate are as follows.</span>
<span class="sd">        (1) 0.0xxxx, (2) 0.xxxx, (3) x.xxx, (4) xx.xx,</span>
<span class="sd">        (5) xxx.x, (6) xxxx.0, (7) xxxx0.0</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        v : tuple</span>
<span class="sd">            X,Y coordinate of the vertex</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the number of significant digits</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_sig</span>

        <span class="c1"># simply return vertex (x,y) coordinates</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="c1"># for each coordinate in a coordinate pair</span>
        <span class="c1"># if the coordinate location is (0.0) simply return zero</span>
        <span class="c1"># else -- (1) take the absolute value of `val`; (2) take the</span>
        <span class="c1"># base 10 log for [1]; (3) take the floor of [2]; (4) convert</span>
        <span class="c1"># [3] into a negative integer; (5) add `sig - 1` to [4];</span>
        <span class="c1"># (6) round `val` by [5]</span>
        <span class="n">out_v</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">val</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">val</span><span class="p">))))</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_v</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.extract_components"><a class="viewcode-back" href="../../generated/spaghetti.Network.extract_components.html#spaghetti.Network.extract_components">[docs]</a>    <span class="k">def</span> <span class="nf">extract_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract connected component information from a</span>
<span class="sd">        ``libpysal.weights.weights.W`` object</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        w : `libpysal.weights.weights.W &lt;https://libpysal.readthedocs.io/en/latest/generated/libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">            Weights object created from the network segments (either</span>
<span class="sd">            raw or graph-theoretic)</span>
<span class="sd">        </span>
<span class="sd">        graph : bool</span>
<span class="sd">            Flag for raw network [False] or graph-theoretic network</span>
<span class="sd">            ``True``. Default is ``False``.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># flag network (arcs) or graph (edges)</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
            <span class="n">obj_type</span> <span class="o">=</span> <span class="s2">&quot;graph_&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span>
            <span class="n">obj_type</span> <span class="o">=</span> <span class="s2">&quot;network_&quot;</span>

        <span class="c1"># connected component count and labels</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">n_components</span>
        <span class="n">component_labels</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">component_labels</span>

        <span class="c1"># link to component lookup</span>
        <span class="n">link2component</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">component_labels</span><span class="p">))</span>

        <span class="c1"># component ID to links lookup</span>
        <span class="n">component2link</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cp_labs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">component_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="n">cp_labs</span><span class="p">:</span>
            <span class="n">component2link</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">link2component</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">cpl</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># component to ring lookup</span>
        <span class="n">component_is_ring</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">component2link</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">component_is_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">component_is_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># attribute label name depends on object type</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">c2l_attr_name</span> <span class="o">=</span> <span class="s2">&quot;component2edge&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c2l_attr_name</span> <span class="o">=</span> <span class="s2">&quot;component2arc&quot;</span>

        <span class="c1"># set all new variables into list</span>
        <span class="n">extracted_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_labels&quot;</span><span class="p">,</span> <span class="n">component_labels</span><span class="p">],</span>
            <span class="p">[</span><span class="n">c2l_attr_name</span><span class="p">,</span> <span class="n">component2link</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_is_ring&quot;</span><span class="p">,</span> <span class="n">component_is_ring</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="c1"># iterate over list and set attribute with</span>
        <span class="c1"># either &quot;network&quot; or &quot;graph&quot; extension</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">attr_str</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">extracted_attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">+</span> <span class="n">attr_str</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network._extractnetwork"><a class="viewcode-back" href="../../generated/spaghetti.Network._extractnetwork.html#spaghetti.Network._extractnetwork">[docs]</a>    <span class="k">def</span> <span class="nf">_extractnetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used internally to extract a network from a polyline</span>
<span class="sd">        shapefile of a ``geopandas.GeoDataFrame``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize vertex count</span>
        <span class="n">vertex_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># determine if input network data is coming from</span>
        <span class="c1"># shapefile or a geopandas.GeoDataFrame</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># iterate over each record of the network lines</span>
        <span class="k">for</span> <span class="n">shp</span> <span class="ow">in</span> <span class="n">shps</span><span class="p">:</span>

            <span class="c1"># fetch all vertices between euclidean segments</span>
            <span class="c1"># in the line record -- these vertices are</span>
            <span class="c1"># coordinates in an (x, y) tuple.</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">_contW_lists</span><span class="o">.</span><span class="n">_get_verts</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>

            <span class="c1"># iterate over each vertex (v)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

                <span class="c1"># -- For vertex 1</span>
                <span class="c1"># adjust precision -- this was originally</span>
                <span class="c1"># implemented to handle high-precision</span>
                <span class="c1"># network network vertices</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_sig</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="c1"># when the vertex already exists in lookup</span>
                <span class="c1"># set it as the current `vid`</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="c1"># when the vertex is not present in the lookup</span>
                <span class="c1"># add it and adjust vertex count</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">vertex_count</span>
                    <span class="n">vertex_count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># -- For vertex 2</span>
                <span class="c1"># repeat the steps above for vertex 1</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_sig</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nvid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nvid</span> <span class="o">=</span> <span class="n">vertex_count</span>
                    <span class="n">vertex_count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># records vertex 1 and vertex 2 adjacency</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nvid</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">nvid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

                <span class="c1"># Sort the edges so that mono-directional</span>
                <span class="c1"># keys can be stored.</span>
                <span class="n">arc_vertices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">vid</span><span class="p">,</span> <span class="n">nvid</span><span class="p">])</span>
                <span class="n">arc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arc_vertices</span><span class="p">)</span>

                <span class="c1"># record the euclidean arc within the network</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>

                <span class="c1"># record length</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_arcs</span><span class="p">:</span>
            <span class="c1"># Remove duplicate edges and duplicate adjacent nodes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="Network.extractgraph"><a class="viewcode-back" href="../../generated/spaghetti.Network.extractgraph.html#spaghetti.Network.extractgraph">[docs]</a>    <span class="k">def</span> <span class="nf">extractgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Using the existing network representation, create a</span>
<span class="sd">        graph-theoretic representation by removing all vertices with a</span>
<span class="sd">        neighbor incidence of two (non-articulation points). That is, we</span>
<span class="sd">        assume these vertices are bridges between vertices with higher</span>
<span class="sd">        or lower incidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize edges and edge_lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># find all vertices with degree 2 that are not in an isolated</span>
        <span class="c1"># island ring (loop) component. These are non-articulation</span>
        <span class="c1"># points on the graph representation</span>
        <span class="n">non_articulation_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_napts</span><span class="p">()</span>
        <span class="c1"># retain non_articulation_points as an attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_articulation_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_articulation_points</span><span class="p">)</span>

        <span class="c1"># start with a copy of the spatial representation and</span>
        <span class="c1"># iteratively remove edges deemed to be segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">)</span>

        <span class="c1"># mapping all the &#39;network arcs&#39; contained within a single</span>
        <span class="c1"># &#39;graph represented&#39; edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># build up bridges &quot;rooted&quot; on the initial</span>
        <span class="c1"># non-articulation points</span>
        <span class="n">bridge_roots</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># iterate over all vertices that are not contained within</span>
        <span class="c1"># isolated loops that have a degree of 2</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">non_articulation_points</span><span class="p">:</span>

            <span class="c1"># initialize bridge with an articulation point</span>
            <span class="n">bridge</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># fetch all vertices adjacent to point `s`</span>
            <span class="c1"># that are also degree 2</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yieldneighbor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">non_articulation_points</span><span class="p">,</span> <span class="n">bridge</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">neighbors</span><span class="p">:</span>

                <span class="c1"># extract the current node in `neighbors`</span>
                <span class="n">cnode</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c1"># remove it from `non_articulation_points`</span>
                <span class="n">non_articulation_points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span>
                <span class="c1"># add it to bridge</span>
                <span class="n">bridge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span>
                <span class="c1"># fetch neighbors for the current node</span>
                <span class="n">newneighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yieldneighbor</span><span class="p">(</span>
                    <span class="n">cnode</span><span class="p">,</span> <span class="n">non_articulation_points</span><span class="p">,</span> <span class="n">bridge</span>
                <span class="p">)</span>
                <span class="c1"># add the new neighbors back into `neighbors`</span>
                <span class="n">neighbors</span> <span class="o">+=</span> <span class="n">newneighbors</span>

            <span class="c1"># once all potential neighbors are exhausted add the</span>
            <span class="c1"># current bridge of non-articulation points to the</span>
            <span class="c1"># list of rooted bridges</span>
            <span class="n">bridge_roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span>

        <span class="c1"># iterate over the list of newly created rooted bridges</span>
        <span class="k">for</span> <span class="n">bridge</span> <span class="ow">in</span> <span class="n">bridge_roots</span><span class="p">:</span>

            <span class="c1"># if the vertex is only one non-articulation</span>
            <span class="c1"># point in the bridge</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="c1"># that the singular element of the bridge</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># and create a new graph edge from it</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

                <span class="c1"># identify the arcs to be removed</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

                <span class="c1"># remove the network arcs (spatial) from the</span>
                <span class="c1"># graph-theoretic representation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>

                <span class="c1"># remove the former network arc lengths from the</span>
                <span class="c1"># graph edge lengths lookup</span>
                <span class="n">length_e1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
                <span class="n">length_e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># and add the new edge length in their place</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">new_edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">length_e1</span> <span class="o">+</span> <span class="n">length_e2</span>

                <span class="c1"># update the pointers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>

            <span class="c1"># if there are more than one vertices in the bridge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cumulative_length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">start_end</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># initialize a redundant set of bridge edges</span>
                <span class="n">redundant</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

                <span class="c1"># iterate over the current bridge</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                    <span class="c1"># iterate over each node in the bridge</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
                        <span class="c1"># start the bridge with this node</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                            <span class="n">start_end</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                        <span class="c1"># or create a redundant edge with the current</span>
                        <span class="c1"># node and `b`</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">redundant</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">])))</span>

                <span class="c1"># initialize a new graph edge</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">start_end</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

                <span class="c1"># add start_end redundant edge</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">start_end</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">redundant</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">])))</span>

                <span class="c1"># remove all redundant network arcs while</span>
                <span class="c1"># adjusting the graph edge lengths lookup</span>
                <span class="c1"># and the edges_to_arcs lookup</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">redundant</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">cumulative_length</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>

                <span class="c1"># finally, add the new cumulative edge length</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">new_edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">cumulative_length</span>

            <span class="c1"># add the updated graph edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

        <span class="c1"># converted the graph edges into a sorted set to prune out</span>
        <span class="c1"># duplicate graph edges created during simplification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span></div>

<div class="viewcode-block" id="Network._yield_napts"><a class="viewcode-back" href="../../generated/spaghetti.Network._yield_napts.html#spaghetti.Network._yield_napts">[docs]</a>    <span class="k">def</span> <span class="nf">_yield_napts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find all nodes with degree 2 that are not in an isolated</span>
<span class="sd">        island ring (loop) component. These are non-articulation</span>
<span class="sd">        points on the graph representation.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        napts : list</span>
<span class="sd">            non-articulation points on a graph representation</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># non-articulation points</span>
        <span class="n">napts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># network vertices remaining to evaluate</span>
        <span class="n">unvisted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">while</span> <span class="n">unvisted</span><span class="p">:</span>

            <span class="c1"># iterate over each component</span>
            <span class="k">for</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_component_is_ring</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># evaluate for non-articulation points</span>
                <span class="n">napts</span><span class="p">,</span> <span class="n">unvisted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_napts</span><span class="p">(</span>
                    <span class="n">napts</span><span class="p">,</span> <span class="n">unvisted</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span>
                <span class="p">)</span>

        <span class="c1"># convert set of non-articulation points into list</span>
        <span class="n">napts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">napts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">napts</span></div>

<div class="viewcode-block" id="Network._evaluate_napts"><a class="viewcode-back" href="../../generated/spaghetti.Network._evaluate_napts.html#spaghetti.Network._evaluate_napts">[docs]</a>    <span class="k">def</span> <span class="nf">_evaluate_napts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">napts</span><span class="p">,</span> <span class="n">unvisited</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate one connected component in a network for</span>
<span class="sd">        non-articulation points (napts) and return an updated set of</span>
<span class="sd">        napts and unvisted vertices.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        napts : set</span>
<span class="sd">            Non-articulation points (napts) in the network. The</span>
<span class="sd">            &#39;napts&#39; here do not include those within an isolated</span>
<span class="sd">            loop island.</span>
<span class="sd">        </span>
<span class="sd">        unvisited : set</span>
<span class="sd">            Vertices left to evaluate in the network.</span>
<span class="sd">        </span>
<span class="sd">        component_id : int</span>
<span class="sd">            ID for the network connected component for the</span>
<span class="sd">            current iteration of the algorithm.</span>
<span class="sd">        </span>
<span class="sd">        ring : bool</span>
<span class="sd">            Network component is isolated island loop ``True`` or</span>
<span class="sd">            not ``False``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        napts : set</span>
<span class="sd">            Updated &#39;napts&#39; object.</span>
<span class="sd">        </span>
<span class="sd">        unvisited : set</span>
<span class="sd">            Updated &#39;napts&#39; object.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># iterate over each `edge` of the `component`</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_component2arc</span><span class="p">[</span><span class="n">component_id</span><span class="p">]:</span>

            <span class="c1"># each `component` has two vertices</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>

                <span class="c1"># if `component` is not an isolated island</span>
                <span class="c1"># and `vertex` has exactly 2 neighbors,</span>
                <span class="c1"># add `vertex` to `napts`</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ring</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">napts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

                <span class="c1"># remove `vertex` from `unvisited` if</span>
                <span class="c1"># it is still in the set else move along to</span>
                <span class="c1"># the next iteration</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">return</span> <span class="n">napts</span><span class="p">,</span> <span class="n">unvisited</span></div>

<div class="viewcode-block" id="Network._yieldneighbor"><a class="viewcode-back" href="../../generated/spaghetti.Network._yieldneighbor.html#spaghetti.Network._yieldneighbor">[docs]</a>    <span class="k">def</span> <span class="nf">_yieldneighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtx</span><span class="p">,</span> <span class="n">arc_vertices</span><span class="p">,</span> <span class="n">bridge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used internally, this method traverses a bridge arc</span>
<span class="sd">        to find the source and destination nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        vtx : int</span>
<span class="sd">            vertex id</span>
<span class="sd">        </span>
<span class="sd">        arc_vertices : list</span>
<span class="sd">            All non-articulation points in the network. These are</span>
<span class="sd">            referred to as degree-2 vertices.</span>
<span class="sd">        </span>
<span class="sd">        bridge : list</span>
<span class="sd">            Inital bridge list containing only ``vtx``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        nodes : list</span>
<span class="sd">            Vertices to keep (articulation points). These elements are </span>
<span class="sd">            referred to as nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate empty lis to fill with network articulation</span>
        <span class="c1"># points (nodes with a degree of 1 [endpoints] or greater</span>
        <span class="c1"># than 2 [intersections])</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get all nodes adjacent to `vtx` that are not in the</span>
        <span class="c1"># set of &#39;bridge&#39; vertices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vtx</span><span class="p">]:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arc_vertices</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="Network.contiguityweights"><a class="viewcode-back" href="../../generated/spaghetti.Network.contiguityweights.html#spaghetti.Network.contiguityweights">[docs]</a>    <span class="k">def</span> <span class="nf">contiguityweights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a contiguity-based libpysal W object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        graph : bool</span>
<span class="sd">            ``{True, False}`` controls whether the W is generated using</span>
<span class="sd">            the spatial representation or the graph representation.</span>
<span class="sd">            Default is ``True``.</span>
<span class="sd">        </span>
<span class="sd">        weightings : dict</span>
<span class="sd">            dictionary of lists of weightings for each arc/edge.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">         W : `libpysal.weights.weights.W &lt;https://libpysal.readthedocs.io/en/latest/generated/libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">            A ``pysal`` W Object representing the binary adjacency of</span>
<span class="sd">            the network.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        Instantiate an instance of a network.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; import esda</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        </span>
<span class="sd">        Snap point observations to the network with</span>
<span class="sd">        attribute information.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;crimes.shp&#39;),</span>
<span class="sd">        ...                      &#39;crimes&#39;, attribute=True)</span>
<span class="sd">        </span>
<span class="sd">        Find counts per network arc.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; counts = ntw.count_per_link(ntw.pointpatterns[&#39;crimes&#39;]</span>
<span class="sd">        ...                             .obs_to_arc, graph=False)</span>
<span class="sd">        &gt;&gt;&gt; counts[(50, 165)]</span>
<span class="sd">        4</span>
<span class="sd">        </span>
<span class="sd">        Create a contiguity based W object.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; w = ntw.contiguityweights(graph=False)</span>
<span class="sd">        </span>
<span class="sd">        Using the W object, access to ESDA functionality is provided.</span>
<span class="sd">        First, a vector of attributes is created for all edges</span>
<span class="sd">        with observations.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; w = ntw.contiguityweights(graph=False)</span>
<span class="sd">        &gt;&gt;&gt; arcs = w.neighbors.keys()</span>
<span class="sd">        &gt;&gt;&gt; y = np.zeros(len(arcs))</span>
<span class="sd">        &gt;&gt;&gt; for i, e in enumerate(arcs):</span>
<span class="sd">        ...     if e in counts.keys():</span>
<span class="sd">        ...         y[i] = counts[e]</span>
<span class="sd">        &gt;&gt;&gt; y[3]</span>
<span class="sd">        3.0</span>
<span class="sd">        </span>
<span class="sd">        Next, a standard call ot Moran is made and the</span>
<span class="sd">        result placed into ``res``.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; res = esda.moran.Moran(y, w, permutations=99)</span>
<span class="sd">        &gt;&gt;&gt; type(res)</span>
<span class="sd">        &lt;class &#39;esda.moran.Moran&#39;&gt;</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate OrderedDict to record network link</span>
        <span class="c1"># adjacency which will be keyed by the link id (a tuple)</span>
        <span class="c1"># with values being lists of tuples (contiguous links)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># flag network (arcs) or graph (edges)</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span>

        <span class="c1"># if weightings are desired instantiate a dictionary</span>
        <span class="c1"># other ignore weightings</span>
        <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
            <span class="n">_weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_weights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># iterate over all links until all possibilities</span>
        <span class="c1"># for network link adjacency are exhausted</span>
        <span class="n">working</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">working</span><span class="p">:</span>

            <span class="c1"># for each network link (1)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>

                <span class="c1"># instantiate a slot in the OrderedDict</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
                    <span class="n">_weights</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># for each network link (2)</span>
                <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>

                    <span class="c1"># skip if comparing link to itself</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># if link(1) and link(2) share any vertex</span>
                    <span class="c1"># update neighbors adjacency</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

                        <span class="c1"># and add weights if desired</span>
                        <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
                            <span class="n">_weights</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weightings</span><span class="p">[</span><span class="n">neigh</span><span class="p">])</span>

                    <span class="c1"># break condition</span>
                    <span class="c1"># -- everything is sorted, so we know when we have</span>
                    <span class="c1"># stepped beyond a possible neighbor</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">working</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># call libpysal for `W` instance</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">_weights</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>

<div class="viewcode-block" id="Network.distancebandweights"><a class="viewcode-back" href="../../generated/spaghetti.Network.distancebandweights.html#spaghetti.Network.distancebandweights">[docs]</a>    <span class="k">def</span> <span class="nf">distancebandweights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">n_proccess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create distance based weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        threshold : float</span>
<span class="sd">            Distance threshold value.</span>
<span class="sd">        </span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            (Optional) Specify the number of cores to utilize. Default</span>
<span class="sd">            is 1 core. Use ``int`` to specify an exact number or cores.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">        </span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path with ``True``, or skip with ``False``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        w : `libpysal.weights.weights.W &lt;https://libpysal.readthedocs.io/en/latest/generated/libpysal.weights.W.html#libpysal.weights.W&gt;`_</span>
<span class="sd">            A ``pysal`` W Object representing the binary adjacency of</span>
<span class="sd">            the network.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; streets_file = examples.get_path(&#39;streets.shp&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(in_data=streets_file)</span>
<span class="sd">        &gt;&gt;&gt; w = ntw.distancebandweights(threshold=500)</span>
<span class="sd">        &gt;&gt;&gt; w.n</span>
<span class="sd">        230</span>
<span class="sd">        &gt;&gt;&gt; w.histogram[-1]</span>
<span class="sd">        (8, 3)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the a vertex-to-vertex network distance matrix is</span>
        <span class="c1"># not present in the `network.Network` object; calculate</span>
        <span class="c1"># one at this point</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;alldistances&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_proccess</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># identify all network vertices which are within the</span>
        <span class="c1"># `threshold` parameter</span>
        <span class="n">neighbor_query</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="c1"># create an instance for recording neighbors which</span>
        <span class="c1"># inserts a new key if not present in object</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># iterate over neighbors within the `threshold`</span>
        <span class="c1"># and record all network vertices as neighbors</span>
        <span class="c1"># if the vertex is not being compared to itself</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbor_query</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">neighbor_query</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">neigh</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

        <span class="c1"># call libpysal for `W` instance</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>

<div class="viewcode-block" id="Network.snapobservations"><a class="viewcode-back" href="../../generated/spaghetti.Network.snapobservations.html#spaghetti.Network.snapobservations">[docs]</a>    <span class="k">def</span> <span class="nf">snapobservations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Snap a point pattern shapefile to network object. The</span>
<span class="sd">        point pattern is stored in the ``network.pointpattern[&#39;key&#39;]``</span>
<span class="sd">        attribute of the network object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        in_data : {geopandas.GeoDataFrame, str}</span>
<span class="sd">            The input geographic data. Either (1) a path to a</span>
<span class="sd">            shapefile (``str``); or (2) a ``geopandas.GeoDataFrame``.</span>
<span class="sd">        </span>
<span class="sd">        name : str</span>
<span class="sd">            Name to be assigned to the point dataset.</span>
<span class="sd">        </span>
<span class="sd">        idvariable : str</span>
<span class="sd">            Column name to be used as ID variable.</span>
<span class="sd">        </span>
<span class="sd">        attribute : bool</span>
<span class="sd">            Defines whether attributes should be extracted. ``True`` for</span>
<span class="sd">            attribute extraction. ``False`` for no attribute extraction.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; streets_file = examples.get_path(&#39;streets.shp&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(in_data=streets_file)</span>
<span class="sd">        &gt;&gt;&gt; pt_str = &#39;crimes&#39;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(&#39;{}.shp&#39;.format(pt_str))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>
<span class="sd">        &gt;&gt;&gt; ntw.pointpatterns[pt_str].npoints</span>
<span class="sd">        287</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create attribute of `pointpattern` but instantiating a</span>
        <span class="c1"># `network.PointPattern` class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PointPattern</span><span class="p">(</span>
            <span class="n">in_data</span><span class="o">=</span><span class="n">in_data</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="n">idvariable</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span>
        <span class="p">)</span>

        <span class="c1"># allocate the point observations to the nework</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snap_to_link</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="Network.compute_distance_to_vertices"><a class="viewcode-back" href="../../generated/spaghetti.Network.compute_distance_to_vertices.html#spaghetti.Network.compute_distance_to_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_distance_to_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">arc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an observation on a network arc, return the distance</span>
<span class="sd">        to the two vertices that bound that end.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        x : float</span>
<span class="sd">            x-coordinate of the snapped point.</span>
<span class="sd">        </span>
<span class="sd">        y : float</span>
<span class="sd">            y-coordinate of the snapped point.</span>
<span class="sd">        </span>
<span class="sd">        arc : tuple</span>
<span class="sd">            (vtx0, vtx1) representation of the network arc.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        d1 : float</span>
<span class="sd">            The distance to vtx0. Always the vertex with the lesser id.</span>
<span class="sd">        </span>
<span class="sd">        d2 : float</span>
<span class="sd">            The distance to vtx1. Always the vertex with the greater id.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># distance to vertex 1</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># distance to vertex 2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span></div>

<div class="viewcode-block" id="Network.compute_snap_dist"><a class="viewcode-back" href="../../generated/spaghetti.Network.compute_snap_dist.html#spaghetti.Network.compute_snap_dist">[docs]</a>    <span class="k">def</span> <span class="nf">compute_snap_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an observation snapped to a network arc, calculate the</span>
<span class="sd">        distance from the original location to the snapped location.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        pattern : spaghetti.network.PointPattern</span>
<span class="sd">            point pattern object</span>
<span class="sd">        </span>
<span class="sd">        idx : int</span>
<span class="sd">            point id</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            euclidean distance from original location to snapped</span>
<span class="sd">            location.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set of original (x,y) point coordinates</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>

        <span class="c1"># set of snapped (x,y) point coordinate</span>
        <span class="n">snp</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># distance from the original location to</span>
        <span class="c1"># the snapped location along the network</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">snp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="Network._snap_to_link"><a class="viewcode-back" href="../../generated/spaghetti.Network._snap_to_link.html#spaghetti.Network._snap_to_link">[docs]</a>    <span class="k">def</span> <span class="nf">_snap_to_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointpattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used internally to snap point observations to network arcs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        pointpattern : spaghetti.network.PointPattern</span>
<span class="sd">            point pattern object</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        obs_to_arc : dict</span>
<span class="sd">            Dictionary with arcs as keys and lists of points as values.</span>
<span class="sd">        </span>
<span class="sd">        arc_to_obs : dict</span>
<span class="sd">            Dictionary with point ids as keys and arc tuples as values.</span>
<span class="sd">        </span>
<span class="sd">        dist_to_vertex : dict</span>
<span class="sd">            Dictionary with point ids as keys and values as dicts</span>
<span class="sd">            with keys for vertex ids and values as distances from point</span>
<span class="sd">            to vertex.</span>
<span class="sd">        </span>
<span class="sd">        dist_snapped : dict</span>
<span class="sd">            Dictionary with point ids as keys and distance from point</span>
<span class="sd">            to the network arc which it is snapped.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate observations snapped coordinates lookup</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># record throw-away arcs (pysal.cg.Chain) enumerator</span>
        <span class="n">arcs_</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># snapped(point)-to-arc lookup</span>
        <span class="n">s2a</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over network arc ids</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">:</span>

            <span class="c1"># record the start and end of the arc</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># create a pysal.cg.Chain object of the arc</span>
            <span class="c1"># and add it to the arcs enumerator</span>
            <span class="n">arcs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">Chain</span><span class="p">([</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">]))</span>

            <span class="c1"># add the arc into the snapped(point)-to-arc lookup</span>
            <span class="n">s2a</span><span class="p">[(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arc</span>

        <span class="c1"># instantiate crosswalks</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># point id to coordinates lookup</span>
        <span class="n">obs_to_arc</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># observations to arcs lookup</span>
        <span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># distance to vertices lookup</span>
        <span class="n">dist_snapped</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># snapped distance lookup</span>

        <span class="c1"># fetch and records point coordinates keyed by id</span>
        <span class="k">for</span> <span class="n">point_idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">pointpattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">points</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>

        <span class="c1"># snap point observations to the network</span>
        <span class="n">snapped</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">snap_points_to_links</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">arcs_</span><span class="p">)</span>

        <span class="c1"># record obs_to_arc, dist_to_vertex, and dist_snapped</span>

        <span class="c1"># iterate over the snapped observation points</span>
        <span class="k">for</span> <span class="n">point_idx</span><span class="p">,</span> <span class="n">snap_info</span> <span class="ow">in</span> <span class="n">snapped</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># fetch the x and y coordinate</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">snap_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># look up the arc from snapped(point)-to-arc</span>
            <span class="n">arc</span> <span class="o">=</span> <span class="n">s2a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">snap_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

            <span class="c1"># add the arc key to observations to arcs lookup</span>
            <span class="k">if</span> <span class="n">arc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obs_to_arc</span><span class="p">:</span>
                <span class="n">obs_to_arc</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># add the (x,y) coordinates of the original observation</span>
            <span class="c1"># point location to the observations to arcs lookup</span>
            <span class="n">obs_to_arc</span><span class="p">[</span><span class="n">arc</span><span class="p">][</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="c1"># add the (x,y) coordinates of the snapped observation</span>
            <span class="c1"># point location to the snapped coordinates lookup</span>
            <span class="n">pointpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="c1"># calculate the distance to the left and right vertex</span>
            <span class="c1"># along the network link from the snapped point location</span>
            <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_distance_to_vertices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span>

            <span class="c1"># record the distances in the distance to vertices lookup</span>
            <span class="n">dist_to_vertex</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">d1</span><span class="p">,</span> <span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">d2</span><span class="p">}</span>

            <span class="c1"># record the snapped distance</span>
            <span class="n">dist_snapped</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_snap_dist</span><span class="p">(</span><span class="n">pointpattern</span><span class="p">,</span> <span class="n">point_idx</span><span class="p">)</span>

        <span class="c1"># instantiate observations to network vertex lookup</span>
        <span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># iterate over the observations to arcs lookup</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obs_to_arc</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># record the left and right vertex ids</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span>
            <span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span>

        <span class="c1"># set crosswalks as attributes of the `pointpattern` class</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">obs_to_arc</span> <span class="o">=</span> <span class="n">obs_to_arc</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="n">dist_to_vertex</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">dist_snapped</span> <span class="o">=</span> <span class="n">dist_snapped</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obs_to_vertex</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.count_per_link"><a class="viewcode-back" href="../../generated/spaghetti.Network.count_per_link.html#spaghetti.Network.count_per_link">[docs]</a>    <span class="k">def</span> <span class="nf">count_per_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs_on</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the counts per arc or edge (link).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        obs_on_network : dict</span>
<span class="sd">            Dictionary of observations on the network.</span>
<span class="sd">            Either {(link):{pt_id:(coords)}} or </span>
<span class="sd">            {link:[(coord),(coord),(coord)]}</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : dict</span>
<span class="sd">            {(link):count}</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        Note that this passes the obs_to_arc or obs_to_edge attribute</span>
<span class="sd">        of a point pattern snapped to the network.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;crimes.shp&#39;),</span>
<span class="sd">        ...                                        &#39;crimes&#39;,</span>
<span class="sd">        ...                                         attribute=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; counts = ntw.count_per_link(ntw.pointpatterns[&#39;crimes&#39;]</span>
<span class="sd">        ...                             .obs_to_arc, graph=False)</span>
<span class="sd">        &gt;&gt;&gt; counts[(140, 142)]</span>
<span class="sd">        10</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; s = sum([v for v in list(counts.values())])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        287</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate observation counts by link lookup</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># graph-theoretic object of nodes and edges</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>

            <span class="c1"># iterate the links-to-observations lookup</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">observations</span> <span class="ow">in</span> <span class="n">obs_on</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># isolate observation count for the link</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

                <span class="c1"># extract link (edges) key</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="c1"># either add to current count or a dictionary</span>
                <span class="c1"># entry or create new dictionary entry</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>

        <span class="c1"># network object of arcs and vertices</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># simplified version of the above process</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obs_on</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_on</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">counts</span></div>

<div class="viewcode-block" id="Network._newpoint_coords"><a class="viewcode-back" href="../../generated/spaghetti.Network._newpoint_coords.html#spaghetti.Network._newpoint_coords">[docs]</a>    <span class="k">def</span> <span class="nf">_newpoint_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arc</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used internally to compute new point</span>
<span class="sd">        coordinates during snapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract coordinates for vertex 1 of arc</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># extract coordinates for vertex 2 of arc</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if the network are is vertical set the (x) coordinate</span>
        <span class="c1"># and proceed to calculating the (y) coordinate</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>

            <span class="c1"># if the vertical direction is positive from</span>
            <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
            <span class="k">if</span> <span class="n">y1</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">distance</span>

            <span class="c1"># if the vertical direction is negative from</span>
            <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
            <span class="k">elif</span> <span class="n">y1</span> <span class="o">&gt;</span> <span class="n">y2</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">distance</span>

            <span class="c1"># otherwise the link is zero-length</span>
            <span class="c1"># -- this should never happen</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y1</span>

            <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span>

        <span class="c1"># calculate the slope of the arc, `m`</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>

        <span class="c1"># if the horizontal direction is negative from</span>
        <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if the horizontal direction is positive from</span>
        <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
        <span class="k">elif</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># calculate the (y) coordinate</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y1</span>

        <span class="c1"># the new (x,y) coordinates for the snapped observation</span>
        <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span></div>

<div class="viewcode-block" id="Network.simulate_observations"><a class="viewcode-back" href="../../generated/spaghetti.Network.simulate_observations.html#spaghetti.Network.simulate_observations">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a simulated point pattern on the network.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        count : int</span>
<span class="sd">            The number of points to create or mean of the distribution</span>
<span class="sd">            if not &#39;uniform&#39;.</span>
<span class="sd">        </span>
<span class="sd">        distribution : str</span>
<span class="sd">            ``{&#39;uniform&#39;, &#39;poisson&#39;}`` distribution of random points.</span>
<span class="sd">            If ``&quot;poisson&quot;``, the distribution is calculated from half</span>
<span class="sd">            the total network length.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        random_pts : dict</span>
<span class="sd">            Keys are the edge tuple. Values are lists of new</span>
<span class="sd">            point coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">       </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;crimes.shp&#39;),</span>
<span class="sd">        ...                                        &#39;crimes&#39;,</span>
<span class="sd">        ...                                         attribute=True)</span>
<span class="sd">       </span>
<span class="sd">        &gt;&gt;&gt; npts = ntw.pointpatterns[&#39;crimes&#39;].npoints</span>
<span class="sd">        &gt;&gt;&gt; sim = ntw.simulate_observations(npts)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(sim, spgh.network.SimulatedPointPattern)</span>
<span class="sd">        True</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate an empty `SimulatedPointPattern()`</span>
        <span class="n">simpts</span> <span class="o">=</span> <span class="n">SimulatedPointPattern</span><span class="p">()</span>

        <span class="c1"># record throw-away arcs enumerator</span>
        <span class="n">arcs_</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create array and fill each entry as length of network arc</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">arcs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># cumulative network length</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="n">totallength</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create lengths with a uniform distribution</span>
        <span class="k">if</span> <span class="n">distribution</span> <span class="ow">is</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">nrandompts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totallength</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">count</span><span class="p">,))</span>

        <span class="c1"># create lengths with a poisson distribution</span>
        <span class="k">elif</span> <span class="n">distribution</span> <span class="ow">is</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
            <span class="c1"># calculate poisson from half the network length</span>
            <span class="n">mid_length</span> <span class="o">=</span> <span class="n">totallength</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">nrandompts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">mid_length</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">count</span><span class="p">,))</span>

        <span class="c1"># iterate over random distances created above</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nrandompts</span><span class="p">):</span>

            <span class="c1"># take the first element of the index array (arc id)</span>
            <span class="c1"># where the random distance is less than that that of</span>
            <span class="c1"># its value in `stops`</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">stops</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># assign the simulated point to the ar</span>
            <span class="n">assignment_arc</span> <span class="o">=</span> <span class="n">arcs_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># calculate and set the distance from the arc start</span>
            <span class="n">distance_from_start</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>

            <span class="c1"># populate the coordinates dict</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newpoint_coords</span><span class="p">(</span><span class="n">assignment_arc</span><span class="p">,</span> <span class="n">distance_from_start</span><span class="p">)</span>

            <span class="c1"># record the snapped coordinates and associated vertices</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">assignment_arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">assignment_arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># calculate and set the distance from the arc end</span>
            <span class="n">distance_from_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arcs_</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">-</span> <span class="n">distance_from_start</span>

            <span class="c1"># populate the distances to vertices</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">assignment_arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">distance_from_start</span><span class="p">,</span>
                <span class="n">assignment_arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">distance_from_end</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="c1"># set snapped coordinates and point count attributes</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">simpts</span><span class="o">.</span><span class="n">snapped_coordinates</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">simpts</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">simpts</span></div>

<div class="viewcode-block" id="Network.enum_links_vertex"><a class="viewcode-back" href="../../generated/spaghetti.Network.enum_links_vertex.html#spaghetti.Network.enum_links_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">enum_links_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the arcs (links) around vertices.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        v0 : int</span>
<span class="sd">            vertex id</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        links : list</span>
<span class="sd">            List of tuple arcs adjacent to the vertex.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.enum_links_vertex(24)</span>
<span class="sd">        [(24, 48), (24, 25), (24, 26)]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate links list</span>
        <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">neighbor_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span>

        <span class="c1"># enumerate links associated with the current vertex</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbor_vertices</span><span class="p">:</span>
            <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">v0</span><span class="p">])))</span>

        <span class="k">return</span> <span class="n">links</span></div>

<div class="viewcode-block" id="Network.full_distance_matrix"><a class="viewcode-back" href="../../generated/spaghetti.Network.full_distance_matrix.html#spaghetti.Network.full_distance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">full_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All vertex-to-vertex distances on a network. This function</span>
<span class="sd">        is called from within ``allneighbordistances()``,</span>
<span class="sd">        ``nearestneighbordistances()``, and ``distancebandweights()``.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        n_processes : int</span>
<span class="sd">            Cpu cores for multiprocessing.</span>
<span class="sd">       </span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        Based on :cite:`Dijkstra1959a`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create `alldistances` attribute which will store</span>
        <span class="c1"># the distance cost matrix and path tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alldistances</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># create an empty matrix which will store shortest path distance</span>
        <span class="n">nvtx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nvtx</span><span class="p">,</span> <span class="n">nvtx</span><span class="p">))</span>

        <span class="c1"># single-core processing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n_processes</span><span class="p">:</span>

            <span class="c1"># iterate over each network vertex</span>
            <span class="k">for</span> <span class="n">vtx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">:</span>

                <span class="c1"># calculate the shortest path and preceding</span>
                <span class="c1"># vertices for traversal route</span>
                <span class="n">distance</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtx</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

                <span class="c1"># generate the shortest path tree</span>
                <span class="k">if</span> <span class="n">gen_tree</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">generatetree</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># populate distances and paths</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alldistances</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>

        <span class="c1"># multiprocessing</span>
        <span class="k">if</span> <span class="n">n_processes</span><span class="p">:</span>

            <span class="c1"># set up multiprocessing schema</span>
            <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
            <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">repeat</span>

            <span class="k">if</span> <span class="n">n_processes</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">cores</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cores</span> <span class="o">=</span> <span class="n">n_processes</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">cores</span><span class="p">)</span>

            <span class="c1"># calculate the shortest path and preceding</span>
            <span class="c1"># vertices for traversal route by mapping each process</span>
            <span class="n">distance_pred</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">dijkstra_mp</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">))</span>

            <span class="c1"># set range of iterations</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_pred</span><span class="p">))</span>

            <span class="c1"># fill shortest paths</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">distance_pred</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">]</span>

            <span class="c1"># fill preceding vertices</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_pred</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">])</span>

            <span class="c1"># iterate of network vertices and generate</span>
            <span class="c1"># the shortest path tree for each</span>
            <span class="k">for</span> <span class="n">vtx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gen_tree</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">generatetree</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">vtx</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># populate distances and paths</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alldistances</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">vtx</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Network.allneighbordistances"><a class="viewcode-back" href="../../generated/spaghetti.Network.allneighbordistances.html#spaghetti.Network.allneighbordistances">[docs]</a>    <span class="k">def</span> <span class="nf">allneighbordistances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sourcepattern</span><span class="p">,</span>
        <span class="n">destpattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_diagonal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snap_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute either all distances between ``i`` and ``j`` in a</span>
<span class="sd">        single point pattern or all distances between each ``i`` from a</span>
<span class="sd">        source pattern and all ``j`` from a destination pattern.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        sourcepattern : {str, spaghetti.network.PointPattern}</span>
<span class="sd">            The key of a point pattern snapped to the network OR</span>
<span class="sd">            the full ``spaghetti.network.PointPattern`` object.</span>
<span class="sd">        </span>
<span class="sd">        destpattern : str</span>
<span class="sd">            (Optional) The key of a point pattern snapped to the network</span>
<span class="sd">            OR the full ``spaghetti.network.PointPattern`` object.</span>
<span class="sd">        </span>
<span class="sd">        fill_diagonal : {float, int}</span>
<span class="sd">            (Optional) Fill the diagonal of the cost matrix. Default is</span>
<span class="sd">            ``None`` and will populate the diagonal with ``numpy.nan``.</span>
<span class="sd">            Do not declare a ``destpattern`` for a custom</span>
<span class="sd">            ``fill_diagonal``.</span>
<span class="sd">        </span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            (Optional) Specify the number of cores to utilize. Default</span>
<span class="sd">            is 1 core. Use ``int`` to specify an exact number or cores.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">        </span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">        </span>
<span class="sd">        snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        nearest : `numpy.ndarray &lt;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">            An array of shape (n,n) storing distances between all</span>
<span class="sd">            points.</span>
<span class="sd">        </span>
<span class="sd">        tree_nearest : dict</span>
<span class="sd">            Nearest network node to point pattern vertex shortest</span>
<span class="sd">            path lookup. The values of the dictionary are a ``tuple``</span>
<span class="sd">            of the nearest source vertex and the near destination</span>
<span class="sd">            vertex to query the lookup tree. If two observations are</span>
<span class="sd">            snapped to the same network arc a flag of -.1 is set for</span>
<span class="sd">            both the source and destination network vertex</span>
<span class="sd">            indicating the same arc is used while also raising an</span>
<span class="sd">            ``IndexError`` when rebuilding the path.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;crimes.shp&#39;),</span>
<span class="sd">        ...                                        &#39;crimes&#39;,</span>
<span class="sd">        ...                                         attribute=True)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; s2s_dist = ntw.allneighbordistances(&#39;crimes&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s2s_dist[0,0], s2s_dist[1,0]</span>
<span class="sd">        (nan, 3105.189475447081)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;schools.shp&#39;),</span>
<span class="sd">        ...                                        &#39;schools&#39;,</span>
<span class="sd">        ...                                        attribute=False)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; s2d_dist = ntw.allneighbordistances(&#39;crimes&#39;,</span>
<span class="sd">        ...                                     destpattern=&#39;schools&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s2d_dist[0,0], s2d_dist[1,0]</span>
<span class="sd">        (4520.72353741989, 6340.422971967315)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; s2d_dist, tree = ntw.allneighbordistances(&#39;schools&#39;,</span>
<span class="sd">        ...                                           gen_tree=True)</span>
<span class="sd">        &gt;&gt;&gt; tree[(6, 7)]</span>
<span class="sd">        (173, 64)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate the network vertex to vertex distance matrix</span>
        <span class="c1"># if it is not already an attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;alldistances&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># set the source and destination observation point patterns</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sourcepattern</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">sourcepattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">sourcepattern</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">destpattern</span><span class="p">:</span>
                <span class="n">destpattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">destpattern</span><span class="p">]</span>

        <span class="c1"># source pattern setup</span>
        <span class="c1"># set local copy of source pattern index</span>
        <span class="n">src_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sourcepattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># set local copy of source distance to vertex lookup</span>
        <span class="n">src_d2v</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sourcepattern</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">)</span>
        <span class="c1"># source point count</span>
        <span class="n">nsource_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
        <span class="c1"># create source point to network vertex lookup</span>
        <span class="n">src_vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">src_indices</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">src_d2v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">src_vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

        <span class="c1"># destination pattern setup</span>
        <span class="c1"># if only a source pattern is specified, also set it as</span>
        <span class="c1"># the destination pattern</span>
        <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">destpattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">destpattern</span> <span class="o">=</span> <span class="n">sourcepattern</span>
        <span class="c1"># set local copy of destination pattern index</span>
        <span class="n">dest_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">destpattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># set local copy of destination distance to vertex lookup</span>
        <span class="n">dst_d2v</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">destpattern</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">)</span>
        <span class="c1"># destination point count</span>
        <span class="n">ndest_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">)</span>
        <span class="c1"># create `deepcopy` of destination points to</span>
        <span class="c1"># consider for searching</span>
        <span class="n">dest_searchpts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">)</span>
        <span class="c1"># create destination point to network vertex lookup</span>
        <span class="n">dest_vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dest_indices</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">dst_d2v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">dest_vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

        <span class="c1"># add snapping distance to each pointpattern</span>
        <span class="k">if</span> <span class="n">snap_dist</span><span class="p">:</span>
            <span class="c1"># declare both point patterns and both</span>
            <span class="c1"># distance to vertex lookup in single lists</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span><span class="n">sourcepattern</span><span class="p">,</span> <span class="n">destpattern</span><span class="p">]</span>
            <span class="n">dist_copies</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_d2v</span><span class="p">,</span> <span class="n">dst_d2v</span><span class="p">]</span>
            <span class="c1"># iterate over each point pattern</span>
            <span class="k">for</span> <span class="n">elm</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patterns</span><span class="p">):</span>
                <span class="c1"># extract associated vertex distances</span>
                <span class="k">for</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">dists_dict</span> <span class="ow">in</span> <span class="n">dist_copies</span><span class="p">[</span><span class="n">elm</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># add snapped distance to each point</span>
                    <span class="k">for</span> <span class="n">vidx</span><span class="p">,</span> <span class="n">vdist</span> <span class="ow">in</span> <span class="n">dists_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dists_dict</span><span class="p">[</span><span class="n">vidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdist</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">dist_snapped</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span>

        <span class="c1"># output setup</span>
        <span class="c1"># create empty source x destination array</span>
        <span class="c1"># and fill with infinity values</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nsource_pts</span><span class="p">,</span> <span class="n">ndest_pts</span><span class="p">))</span>
        <span class="n">nearest</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># create empty dictionary to store path trees</span>
        <span class="n">tree_nearest</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over each point in sources</span>
        <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">src_indices</span><span class="p">:</span>

            <span class="c1"># get the source vertices and dist to source vertices</span>
            <span class="n">source1</span><span class="p">,</span> <span class="n">source2</span> <span class="o">=</span> <span class="n">src_vertices</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_vertices</span><span class="p">[</span><span class="n">p1</span><span class="p">])</span>

            <span class="c1"># distance from source vertex1 to point and</span>
            <span class="c1"># distance from source vertex2 to point</span>
            <span class="n">sdist1</span><span class="p">,</span> <span class="n">sdist2</span> <span class="o">=</span> <span class="n">src_d2v</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>

                <span class="c1"># only compute the upper triangle if symmetric</span>
                <span class="n">dest_searchpts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

            <span class="c1"># iterate over each point remaining in destinations</span>
            <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">dest_searchpts</span><span class="p">:</span>

                <span class="c1"># get the destination vertices and</span>
                <span class="c1"># dist to destination vertices</span>
                <span class="n">dest1</span><span class="p">,</span> <span class="n">dest2</span> <span class="o">=</span> <span class="n">dest_vertices</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dest_vertices</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span>

                <span class="c1"># when the observations are snapped to the same arc</span>
                <span class="k">if</span> <span class="n">set1</span> <span class="o">==</span> <span class="n">set2</span><span class="p">:</span>

                    <span class="c1"># calculate only the length between points along</span>
                    <span class="c1"># that arc</span>
                    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">sourcepattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
                    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">destpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>

                    <span class="n">computed_length</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">computed_length</span>

                    <span class="c1"># set the nearest network vertices to a flag of -.1</span>
                    <span class="c1"># indicating the same arc is used while also raising</span>
                    <span class="c1"># and indexing error when rebuilding the path</span>
                    <span class="n">tree_nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>

                <span class="c1"># otherwise lookup distance between the source and</span>
                <span class="c1"># destination vertex from the `distancematrix`</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># distance from destination vertex1 to point and</span>
                    <span class="c1"># distance from destination vertex2 to point</span>
                    <span class="n">ddist1</span><span class="p">,</span> <span class="n">ddist2</span> <span class="o">=</span> <span class="n">dst_d2v</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

                    <span class="c1"># set the four possible combinations of</span>
                    <span class="c1"># source to destination shortest path traversal</span>
                    <span class="n">d11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">source1</span><span class="p">][</span><span class="n">dest1</span><span class="p">]</span>
                    <span class="n">d21</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">source2</span><span class="p">][</span><span class="n">dest1</span><span class="p">]</span>
                    <span class="n">d12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">source1</span><span class="p">][</span><span class="n">dest2</span><span class="p">]</span>
                    <span class="n">d22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">[</span><span class="n">source2</span><span class="p">][</span><span class="n">dest2</span><span class="p">]</span>

                    <span class="c1"># find the shortest distance from the path passing</span>
                    <span class="c1"># through each of the two origin vertices to the</span>
                    <span class="c1"># first destination vertex</span>
                    <span class="n">sd_1</span> <span class="o">=</span> <span class="n">d11</span> <span class="o">+</span> <span class="n">sdist1</span>
                    <span class="n">sd_21</span> <span class="o">=</span> <span class="n">d21</span> <span class="o">+</span> <span class="n">sdist2</span>
                    <span class="n">sp_combo1</span> <span class="o">=</span> <span class="n">source1</span><span class="p">,</span> <span class="n">dest1</span>
                    <span class="k">if</span> <span class="n">sd_1</span> <span class="o">&gt;</span> <span class="n">sd_21</span><span class="p">:</span>
                        <span class="n">sd_1</span> <span class="o">=</span> <span class="n">sd_21</span>
                        <span class="n">sp_combo1</span> <span class="o">=</span> <span class="n">source2</span><span class="p">,</span> <span class="n">dest1</span>

                    <span class="c1"># now add the point to vertex1 distance on</span>
                    <span class="c1"># the destination arc</span>
                    <span class="n">len_1</span> <span class="o">=</span> <span class="n">sd_1</span> <span class="o">+</span> <span class="n">ddist1</span>

                    <span class="c1"># repeat the prior but now for the paths entering</span>
                    <span class="c1"># at the second vertex of the second arc</span>
                    <span class="n">sd_2</span> <span class="o">=</span> <span class="n">d12</span> <span class="o">+</span> <span class="n">sdist1</span>
                    <span class="n">sd_22</span> <span class="o">=</span> <span class="n">d22</span> <span class="o">+</span> <span class="n">sdist2</span>
                    <span class="n">sp_combo2</span> <span class="o">=</span> <span class="n">source1</span><span class="p">,</span> <span class="n">dest2</span>
                    <span class="k">if</span> <span class="n">sd_2</span> <span class="o">&gt;</span> <span class="n">sd_22</span><span class="p">:</span>
                        <span class="n">sd_2</span> <span class="o">=</span> <span class="n">sd_22</span>
                        <span class="n">sp_combo2</span> <span class="o">=</span> <span class="n">source2</span><span class="p">,</span> <span class="n">dest2</span>
                    <span class="n">len_2</span> <span class="o">=</span> <span class="n">sd_2</span> <span class="o">+</span> <span class="n">ddist2</span>

                    <span class="c1"># now find the shortest distance path between point</span>
                    <span class="c1"># 1 on arc 1 and point 2 on arc 2, and assign</span>
                    <span class="n">sp_12</span> <span class="o">=</span> <span class="n">len_1</span>
                    <span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span> <span class="o">=</span> <span class="n">sp_combo1</span>
                    <span class="k">if</span> <span class="n">len_1</span> <span class="o">&gt;</span> <span class="n">len_2</span><span class="p">:</span>
                        <span class="n">sp_12</span> <span class="o">=</span> <span class="n">len_2</span>
                        <span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span> <span class="o">=</span> <span class="n">sp_combo2</span>

                    <span class="c1"># set distance and path tree</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_12</span>
                    <span class="n">tree_nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>

                    <span class="c1"># mirror the upper and lower triangle</span>
                    <span class="c1"># when symmetric</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>

        <span class="c1"># populate the main diagonal when symmetric</span>
        <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>

            <span class="c1"># fill the matrix diagonal with NaN values is no fill</span>
            <span class="c1"># value is specified</span>
            <span class="k">if</span> <span class="n">fill_diagonal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># otherwise fill with specified value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">fill_diagonal</span><span class="p">)</span>

        <span class="c1"># if the nearest path tree is desired return it along</span>
        <span class="c1"># with the cost matrix</span>
        <span class="k">if</span> <span class="n">gen_tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nearest</span><span class="p">,</span> <span class="n">tree_nearest</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nearest</span></div>

<div class="viewcode-block" id="Network.nearestneighbordistances"><a class="viewcode-back" href="../../generated/spaghetti.Network.nearestneighbordistances.html#spaghetti.Network.nearestneighbordistances">[docs]</a>    <span class="k">def</span> <span class="nf">nearestneighbordistances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sourcepattern</span><span class="p">,</span>
        <span class="n">destpattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">all_dists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_zero_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the interpattern nearest neighbor distances or the</span>
<span class="sd">        intrapattern nearest neighbor distances between a source</span>
<span class="sd">        pattern and a destination pattern.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        sourcepattern : str</span>
<span class="sd">            The key of a point pattern snapped to the network.</span>
<span class="sd">        </span>
<span class="sd">        destpattern : str</span>
<span class="sd">            (Optional) The key of a point pattern snapped to the</span>
<span class="sd">            network.</span>
<span class="sd">        </span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            (Optional) Specify the number of cores to utilize. Default</span>
<span class="sd">            is 1 core. Use ``int`` to specify an exact number or cores.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">        </span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">        </span>
<span class="sd">        all_dists : `numpy.ndarray &lt;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">            An array of shape (n,n) storing distances between all</span>
<span class="sd">            points.</span>
<span class="sd">        </span>
<span class="sd">        snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>
<span class="sd">        </span>
<span class="sd">        keep_zero_dist : bool</span>
<span class="sd">            Include zero values in minimum distance ``True`` or exclude</span>
<span class="sd">            ``False``. Default is ``True``. If the source pattern is the</span>
<span class="sd">            same as the destination pattern the diagonal is filled with</span>
<span class="sd">            ``numpy.nan``.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nearest : dict</span>
<span class="sd">            key is source point id, value is tuple of list containing</span>
<span class="sd">            nearest destination point ids and distance.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&#39;crimes.shp&#39;),</span>
<span class="sd">        ...                      &#39;crimes&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nn = ntw.nearestneighbordistances(&#39;crimes&#39;,</span>
<span class="sd">        ...                                   keep_zero_dist=True)</span>
<span class="sd">        &gt;&gt;&gt; nn[11], nn[18]</span>
<span class="sd">        (([18, 19], 165.33982412719126), ([19], 0.0))</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; nn = ntw.nearestneighbordistances(&#39;crimes&#39;,</span>
<span class="sd">        ...                                   keep_zero_dist=False)</span>
<span class="sd">        &gt;&gt;&gt; nn[11], nn[18]</span>
<span class="sd">        (([18, 19], 165.33982412719126), ([11], 165.33982412719126))</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># raise exception is the specified point pattern does not exist</span>
        <span class="k">if</span> <span class="n">sourcepattern</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Available point patterns are </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># calculate the network vertex to vertex distance matrix</span>
        <span class="c1"># if it is not already an attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;alldistances&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># determine if the source and destination patterns are equal</span>
        <span class="n">symmetric</span> <span class="o">=</span> <span class="n">sourcepattern</span> <span class="o">!=</span> <span class="n">destpattern</span>

        <span class="c1"># (for source-to-source patterns) if zero-distance neighbors are</span>
        <span class="c1"># desired, keep the diagonal as NaN and take the minimum</span>
        <span class="c1"># distance neighbor(s), which may include zero distance</span>
        <span class="c1"># neighors.</span>
        <span class="n">fill_diagonal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_zero_dist</span> <span class="ow">and</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># (for source-to-source patterns) if zero-distance neighbors</span>
            <span class="c1"># should be ignored, convert the diagonal to 0.0 and take</span>
            <span class="c1"># the minimum distance neighbor(s) that is/are not 0.0</span>
            <span class="c1"># distance.</span>
            <span class="n">fill_diagonal</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># set the source and destination observation point patterns</span>
        <span class="n">sourcepattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">sourcepattern</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">destpattern</span><span class="p">:</span>
            <span class="n">destpattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">destpattern</span><span class="p">]</span>

        <span class="c1"># if the full source to destination is not calculated,</span>
        <span class="c1"># do that at this time</span>
        <span class="k">if</span> <span class="n">all_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allneighbordistances</span><span class="p">(</span>
                <span class="n">sourcepattern</span><span class="p">,</span>
                <span class="n">destpattern</span><span class="o">=</span><span class="n">destpattern</span><span class="p">,</span>
                <span class="n">fill_diagonal</span><span class="o">=</span><span class="n">fill_diagonal</span><span class="p">,</span>
                <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">,</span>
                <span class="n">snap_dist</span><span class="o">=</span><span class="n">snap_dist</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># create empty nearest neighbors lookup</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over each source point</span>
        <span class="k">for</span> <span class="n">source_index</span> <span class="ow">in</span> <span class="n">sourcepattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1"># this considers all zero-distance neighbors</span>
            <span class="k">if</span> <span class="n">keep_zero_dist</span> <span class="ow">and</span> <span class="n">symmetric</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:])</span>

            <span class="c1"># this does not consider zero-distance neighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                    <span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:])]</span>
                <span class="p">)</span>

            <span class="c1"># nearest destination (may be more than one if</span>
            <span class="c1"># observations are equal distances away)</span>
            <span class="n">dest_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># set nearest destination point(s) and distance</span>
            <span class="n">nearest</span><span class="p">[</span><span class="n">source_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dest_idxs</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nearest</span></div>

<div class="viewcode-block" id="Network.NetworkF"><a class="viewcode-back" href="../../generated/spaghetti.Network.NetworkF.html#spaghetti.Network.NetworkF">[docs]</a>    <span class="k">def</span> <span class="nf">NetworkF</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointpattern</span><span class="p">,</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">lowerbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">upperbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a network constrained F-Function</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        pointpattern : spaghetti.network.PointPattern</span>
<span class="sd">            A spaghetti point pattern object.</span>
<span class="sd">        </span>
<span class="sd">        nsteps : int</span>
<span class="sd">            The number of steps at which the count of the nearest</span>
<span class="sd">            neighbors is computed.</span>
<span class="sd">        </span>
<span class="sd">        permutations : int</span>
<span class="sd">            The number of permutations to perform. Default 99.</span>
<span class="sd">        </span>
<span class="sd">        threshold : float</span>
<span class="sd">            The level at which significance is computed.</span>
<span class="sd">            (0.5 would be 97.5% and 2.5%).</span>
<span class="sd">        </span>
<span class="sd">        distribution : str</span>
<span class="sd">            The distribution from which random points are sampled.</span>
<span class="sd">            Either ``&quot;uniform&quot;`` or ``&quot;poisson&quot;``.</span>
<span class="sd">        </span>
<span class="sd">        lowerbound : float</span>
<span class="sd">            The lower bound at which the F-function is computed.</span>
<span class="sd">            Default 0.</span>
<span class="sd">        </span>
<span class="sd">        upperbound : float</span>
<span class="sd">            The upper bound at which the F-function is computed.</span>
<span class="sd">            Defaults to the maximum observed nearest neighbor distance.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        NetworkF : spaghetti.analysis.NetworkF</span>
<span class="sd">            A network F class instance.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(in_data=examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; pt_str = &#39;crimes&#39;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(&#39;{}.shp&#39;.format(pt_str))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>
<span class="sd">        &gt;&gt;&gt; crimes = ntw.pointpatterns[&#39;crimes&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sim = ntw.simulate_observations(crimes.npoints)</span>
<span class="sd">        &gt;&gt;&gt; fres = ntw.NetworkF(crimes, permutations=5, nsteps=10)</span>
<span class="sd">        &gt;&gt;&gt; fres.lowerenvelope.shape[0]</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call analysis.NetworkF</span>
        <span class="k">return</span> <span class="n">NetworkF</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pointpattern</span><span class="p">,</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">,</span>
            <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">distribution</span><span class="o">=</span><span class="n">distribution</span><span class="p">,</span>
            <span class="n">lowerbound</span><span class="o">=</span><span class="n">lowerbound</span><span class="p">,</span>
            <span class="n">upperbound</span><span class="o">=</span><span class="n">upperbound</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Network.NetworkG"><a class="viewcode-back" href="../../generated/spaghetti.Network.NetworkG.html#spaghetti.Network.NetworkG">[docs]</a>    <span class="k">def</span> <span class="nf">NetworkG</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointpattern</span><span class="p">,</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">lowerbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">upperbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a network constrained G-Function</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        pointpattern : spaghetti.network.PointPattern</span>
<span class="sd">            A spaghetti point pattern object.</span>
<span class="sd">        </span>
<span class="sd">        nsteps : int</span>
<span class="sd">            The number of steps at which the count of the nearest</span>
<span class="sd">            neighbors is computed.</span>
<span class="sd">        </span>
<span class="sd">        permutations : int</span>
<span class="sd">            The number of permutations to perform. Default 99.</span>
<span class="sd">        </span>
<span class="sd">        threshold : float</span>
<span class="sd">            The level at which significance is computed.</span>
<span class="sd">            (0.5 would be 97.5% and 2.5%).</span>
<span class="sd">        </span>
<span class="sd">        distribution : str</span>
<span class="sd">            The distribution from which random points are sampled</span>
<span class="sd">            Either ``&quot;uniform&quot;`` or ``&quot;poisson&quot;``.</span>
<span class="sd">        </span>
<span class="sd">        lowerbound : float</span>
<span class="sd">            The lower bound at which the G-function is computed.</span>
<span class="sd">            Default 0.</span>
<span class="sd">        </span>
<span class="sd">        upperbound : float</span>
<span class="sd">            The upper bound at which the G-function is computed.</span>
<span class="sd">            Defaults to the maximum observed nearest neighbor distance.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        NetworkG : spaghetti.analysis.NetworkG</span>
<span class="sd">            A network G class instance.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(in_data=examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; pt_str = &#39;crimes&#39;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(&#39;{}.shp&#39;.format(pt_str))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>
<span class="sd">        &gt;&gt;&gt; crimes = ntw.pointpatterns[&#39;crimes&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sim = ntw.simulate_observations(crimes.npoints)</span>
<span class="sd">        &gt;&gt;&gt; gres = ntw.NetworkG(crimes, permutations=5, nsteps=10)</span>
<span class="sd">        &gt;&gt;&gt; gres.lowerenvelope.shape[0]</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call analysis.NetworkG</span>
        <span class="k">return</span> <span class="n">NetworkG</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pointpattern</span><span class="p">,</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">,</span>
            <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">distribution</span><span class="o">=</span><span class="n">distribution</span><span class="p">,</span>
            <span class="n">lowerbound</span><span class="o">=</span><span class="n">lowerbound</span><span class="p">,</span>
            <span class="n">upperbound</span><span class="o">=</span><span class="n">upperbound</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Network.NetworkK"><a class="viewcode-back" href="../../generated/spaghetti.Network.NetworkK.html#spaghetti.Network.NetworkK">[docs]</a>    <span class="k">def</span> <span class="nf">NetworkK</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointpattern</span><span class="p">,</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">lowerbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">upperbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a network constrained K-Function</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        pointpattern : spaghetti.network.PointPattern</span>
<span class="sd">            A spaghetti point pattern object.</span>
<span class="sd">        </span>
<span class="sd">        nsteps : int</span>
<span class="sd">            The number of steps at which the count of the nearest</span>
<span class="sd">            neighbors is computed.</span>
<span class="sd">        </span>
<span class="sd">        permutations : int</span>
<span class="sd">            The number of permutations to perform. Default is 99.</span>
<span class="sd">        </span>
<span class="sd">        threshold : float</span>
<span class="sd">            The level at which significance is computed.</span>
<span class="sd">            (0.5 would be 97.5% and 2.5%).</span>
<span class="sd">        </span>
<span class="sd">        distribution : str</span>
<span class="sd">            The distribution from which random points are sampled</span>
<span class="sd">            Either ``&quot;uniform&quot;`` or ``&quot;poisson&quot;``.</span>
<span class="sd">        </span>
<span class="sd">        lowerbound : float</span>
<span class="sd">            The lower bound at which the K-function is computed.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        </span>
<span class="sd">        upperbound : float</span>
<span class="sd">            The upper bound at which the K-function is computed.</span>
<span class="sd">            Defaults to the maximum observed nearest neighbor distance.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        NetworkK : spaghetti.analysis.NetworkK</span>
<span class="sd">            A network K class instance.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        Based on :cite:`Okabe2001`.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(in_data=examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; pt_str = &#39;crimes&#39;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(&#39;{}.shp&#39;.format(pt_str))</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>
<span class="sd">        &gt;&gt;&gt; crimes = ntw.pointpatterns[&#39;crimes&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sim = ntw.simulate_observations(crimes.npoints)</span>
<span class="sd">        &gt;&gt;&gt; kres = ntw.NetworkK(crimes, permutations=5, nsteps=10)</span>
<span class="sd">        &gt;&gt;&gt; kres.lowerenvelope.shape[0]</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call analysis.NetworkK</span>
        <span class="k">return</span> <span class="n">NetworkK</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pointpattern</span><span class="p">,</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">,</span>
            <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">distribution</span><span class="o">=</span><span class="n">distribution</span><span class="p">,</span>
            <span class="n">lowerbound</span><span class="o">=</span><span class="n">lowerbound</span><span class="p">,</span>
            <span class="n">upperbound</span><span class="o">=</span><span class="n">upperbound</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Network.split_arcs"><a class="viewcode-back" href="../../generated/spaghetti.Network.split_arcs.html#spaghetti.Network.split_arcs">[docs]</a>    <span class="k">def</span> <span class="nf">split_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split all of the arcs in the network at a fixed distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        distance : float</span>
<span class="sd">            The distance at which arcs are split.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        split_network : spaghetti.Network</span>
<span class="sd">            newly instantiated ``spaghetti.Network`` object.</span>
<span class="sd">        </span>
<span class="sd">       Examples</span>
<span class="sd">        --------</span>
<span class="sd">       </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; n200 = ntw.split_arcs(200.0)</span>
<span class="sd">        &gt;&gt;&gt; len(n200.arcs)</span>
<span class="sd">        688</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create new shell network instance</span>
        <span class="n">split_network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>

        <span class="c1"># duplicate input network attributes</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">))</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">pointpatterns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span>

        <span class="c1"># set vertex id to start iterations</span>
        <span class="n">current_vertex_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># instantiate sets for newly created network arcs and</span>
        <span class="c1"># input network arcs to remove</span>
        <span class="n">new_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">remove_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># iterate over all network arcs</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="p">:</span>

            <span class="c1"># fetch network arc length</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span>

            <span class="c1"># set initial segmentation interval</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">distance</span>

            <span class="c1"># initialize arc new arc length at zero</span>
            <span class="n">totallength</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># initialize the starting vertex, current vertex, and</span>
            <span class="c1"># ending vertex</span>
            <span class="n">currentstart</span> <span class="o">=</span> <span class="n">start_vertex</span> <span class="o">=</span> <span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end_vertex</span> <span class="o">=</span> <span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># if the arc will be split remove the current</span>
            <span class="c1"># arc from the adjacency list</span>
            <span class="k">if</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>

                <span class="c1"># remove old arc adjacency information</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># remove old arc length information</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># add old arc to set of arcs to remove</span>
                <span class="n">remove_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>

            <span class="c1"># if the arc will not be split, do nothing and continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># traverse the length of the arc</span>
            <span class="k">while</span> <span class="n">totallength</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>

                <span class="c1"># set/update the current vertex id</span>
                <span class="n">currentstop</span> <span class="o">=</span> <span class="n">current_vertex_id</span>

                <span class="c1"># once an can not be split further</span>
                <span class="k">if</span> <span class="n">totallength</span> <span class="o">+</span> <span class="n">interval</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
                    <span class="c1"># record the ending vertex</span>
                    <span class="n">currentstop</span> <span class="o">=</span> <span class="n">end_vertex</span>
                    <span class="c1"># set the length remainder</span>
                    <span class="n">interval</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">totallength</span>
                    <span class="c1"># full old length reached</span>
                    <span class="n">totallength</span> <span class="o">=</span> <span class="n">length</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set the current vertex id</span>
                    <span class="n">current_vertex_id</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># set the current stopping id</span>
                    <span class="n">currentstop</span> <span class="o">=</span> <span class="n">current_vertex_id</span>
                    <span class="c1"># add the interval distance to the traversed length</span>
                    <span class="n">totallength</span> <span class="o">+=</span> <span class="n">interval</span>

                    <span class="c1"># compute the new vertex coordinate</span>
                    <span class="n">newx</span><span class="p">,</span> <span class="n">newy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newpoint_coords</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">totallength</span><span class="p">)</span>

                    <span class="c1"># update the vertex</span>
                    <span class="k">if</span> <span class="n">currentstop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">:</span>
                        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstop</span><span class="p">)</span>

                    <span class="c1"># update vertex coordinates and vertex id</span>
                    <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">currentstop</span><span class="p">]</span> <span class="o">=</span> <span class="n">newx</span><span class="p">,</span> <span class="n">newy</span>
                    <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span><span class="p">[(</span><span class="n">newx</span><span class="p">,</span> <span class="n">newy</span><span class="p">)]</span> <span class="o">=</span> <span class="n">currentstop</span>

                <span class="c1"># update the new network adjacency list</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">currentstart</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstop</span><span class="p">)</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">currentstop</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstart</span><span class="p">)</span>

                <span class="c1"># add the new arc to the arc dictionary</span>
                <span class="c1"># iterating over this so we need to add after iterating</span>
                <span class="n">new_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">currentstart</span><span class="p">,</span> <span class="n">currentstop</span><span class="p">])))</span>

                <span class="c1"># modify arc_lengths</span>
                <span class="n">current_start_stop</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">currentstart</span><span class="p">,</span> <span class="n">currentstop</span><span class="p">]))</span>

                <span class="c1"># set the length of the arc</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">current_start_stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>

                <span class="c1"># increment the starting vertex to the stopping vertex</span>
                <span class="n">currentstart</span> <span class="o">=</span> <span class="n">currentstop</span>

        <span class="c1"># add the newly created arcs to the network</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_arcs</span><span class="p">)</span>

        <span class="c1"># remove the old arcs the network</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">remove_arcs</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>

        <span class="c1"># update the snapped point pattern</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">pointpatterns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">split_network</span><span class="o">.</span><span class="n">_snap_to_link</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">split_network</span></div>

<div class="viewcode-block" id="Network.savenetwork"><a class="viewcode-back" href="../../generated/spaghetti.Network.savenetwork.html#spaghetti.Network.savenetwork">[docs]</a>    <span class="k">def</span> <span class="nf">savenetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save a network to disk as a binary file.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename where the network should be saved. This should</span>
<span class="sd">            be a full path or it will be save in the current directory.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import spaghetti as spgh</span>
<span class="sd">        &gt;&gt;&gt; ntw = spgh.Network(examples.get_path(&#39;streets.shp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; ntw.savenetwork(&#39;mynetwork.pkl&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">networkout</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">networkout</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.loadnetwork"><a class="viewcode-back" href="../../generated/spaghetti.Network.loadnetwork.html#spaghetti.Network.loadnetwork">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">loadnetwork</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a network from a binary file saved on disk.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename where the network should be saved.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        self : spaghetti.Network</span>
<span class="sd">            spaghetti Network object</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">networkin</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">networkin</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="element_as_gdf"><a class="viewcode-back" href="../../generated/spaghetti.element_as_gdf.html#spaghetti.element_as_gdf">[docs]</a><span class="k">def</span> <span class="nf">element_as_gdf</span><span class="p">(</span>
    <span class="n">net</span><span class="p">,</span>
    <span class="n">vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">arcs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">pp_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">snapped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">id_col</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="n">geom_col</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a `geopandas.GeoDataFrame </span>
<span class="sd">    &lt;http://geopandas.org/data_structures.html#geodataframe&gt;`_ of</span>
<span class="sd">    network elements. This can be (a) the vertices of a network; (b) the</span>
<span class="sd">    arcs of a network; (c) both the vertices and arcs of the network;</span>
<span class="sd">    (d) raw point pattern associated with the network; or (e) snapped</span>
<span class="sd">    point pattern of (d).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        network object</span>
<span class="sd">    </span>
<span class="sd">    vertices : bool</span>
<span class="sd">        Extract the network vertices. Default is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    arcs : bool</span>
<span class="sd">        Extract the network arcs. Default is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    pp_name : str</span>
<span class="sd">        Name of the network ``PointPattern`` to extract.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    </span>
<span class="sd">    snapped : bool</span>
<span class="sd">        If extracting a network ``PointPattern``, set to ``True`` for</span>
<span class="sd">        snapped point locations along the network. Default is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    id_col : str</span>
<span class="sd">        GeoDataFrame column name for IDs. Default is ``&#39;id&#39;``.</span>
<span class="sd">    </span>
<span class="sd">    geom_col : str</span>
<span class="sd">        GeoDataFrame column name for geometry. Default is</span>
<span class="sd">        ``&#39;geometry&#39;``.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    </span>
<span class="sd">    KeyError</span>
<span class="sd">        In order to extract a ``PointPattern`` it must already be a part</span>
<span class="sd">        of the ``spaghetti.Network`` object. This exception is raised</span>
<span class="sd">        when a ``PointPattern`` is being extracted that does not exist</span>
<span class="sd">        within the ``spaghetti.Network`` object.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    points : geopandas.GeoDataFrame</span>
<span class="sd">        Network point elements (either vertices or ``PointPattern``</span>
<span class="sd">        points) as a `geopandas.GeoDataFrame` of ``shapely.Point``</span>
<span class="sd">        objects with an ``id`` column and ``geometry`` column.</span>
<span class="sd">    </span>
<span class="sd">    lines : geopandas.GeoDataFrame</span>
<span class="sd">        Network arc elements as a ``geopandas.GeoDataFrame`` of</span>
<span class="sd">        ``shapely.LineString`` objects with an ``id`` column and</span>
<span class="sd">        ``geometry`` column.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">    This function requires `geopandas &lt;http://geopandas.org&gt;`_.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># need vertices place holder to create network segment LineStrings</span>
    <span class="c1"># even if only network edges are desired.</span>
    <span class="n">vertices_for_arcs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">arcs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">vertices_for_arcs</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># vertices/nodes/points</span>
    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">or</span> <span class="n">vertices_for_arcs</span> <span class="ow">or</span> <span class="n">pp_name</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_points_as_gdf</span><span class="p">(</span>
            <span class="n">net</span><span class="p">,</span>
            <span class="n">vertices</span><span class="p">,</span>
            <span class="n">vertices_for_arcs</span><span class="p">,</span>
            <span class="n">pp_name</span><span class="p">,</span>
            <span class="n">snapped</span><span class="p">,</span>
            <span class="n">id_col</span><span class="o">=</span><span class="n">id_col</span><span class="p">,</span>
            <span class="n">geom_col</span><span class="o">=</span><span class="n">geom_col</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># return points geodataframe if arcs not specified or</span>
        <span class="c1"># if extracting `PointPattern` points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span> <span class="ow">or</span> <span class="n">pp_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>

    <span class="c1"># arcs</span>
    <span class="n">arcs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_arcs_as_gdf</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">id_col</span><span class="o">=</span><span class="n">id_col</span><span class="p">,</span> <span class="n">geom_col</span><span class="o">=</span><span class="n">geom_col</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">vertices_for_arcs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arcs</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">arcs</span></div>


<div class="viewcode-block" id="PointPattern"><a class="viewcode-back" href="../../generated/spaghetti.PointPattern.html#spaghetti.PointPattern">[docs]</a><span class="k">class</span> <span class="nc">PointPattern</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A stub point pattern class used to store a point pattern. This</span>
<span class="sd">    class is monkey patched with network specific attributes when the</span>
<span class="sd">    points are snapped to a network. In the future this class may be</span>
<span class="sd">    replaced with a generic point pattern class.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    in_data : {geopandas.GeoDataFrame, str}</span>
<span class="sd">        The input geographic data. Either (1) a path to a shapefile</span>
<span class="sd">        ``str``; or (2) a `geopandas.GeoDataFrame </span>
<span class="sd">        &lt;http://geopandas.org/data_structures.html#geodataframe&gt;`_.</span>
<span class="sd">        </span>
<span class="sd">    idvariable : str</span>
<span class="sd">        Field in the shapefile to use as an id variable.</span>
<span class="sd">    </span>
<span class="sd">    attribute :  bool</span>
<span class="sd">        A flag to indicate whether all attributes are tagged to this</span>
<span class="sd">        class (``True``) or excluded (``False``). Default is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    points : dict</span>
<span class="sd">        Keys are the point ids (int). Values are the x,y</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    </span>
<span class="sd">    npoints : int</span>
<span class="sd">        The number of points.</span>
<span class="sd">    </span>
<span class="sd">    obs_to_arc : dict</span>
<span class="sd">        Keys are arc ids (tuple). Values are snapped point information</span>
<span class="sd">        (``dict``).  Within the snapped point information (``dict``)</span>
<span class="sd">        keys are observation ids (``int``), and values are snapped</span>
<span class="sd">        coordinates.</span>
<span class="sd">    </span>
<span class="sd">    obs_to_vertex : list</span>
<span class="sd">       List of incident network vertices to snapped observation points</span>
<span class="sd">       converted from a ``default_dict``. Originally in the form of</span>
<span class="sd">       paired left/right nearest network vertices {netvtx1: obs_id1,</span>
<span class="sd">       netvtx2: obs_id1, netvtx1: obs_id2... netvtx1: obs_idn}, then</span>
<span class="sd">       simplified to a list in the form</span>
<span class="sd">       [netvtx1, netvtx2, netvtx1, netvtx2, ...].</span>
<span class="sd">       </span>
<span class="sd">    dist_to_vertex : dict</span>
<span class="sd">        Keys are observations ids (``int``). Values are distance lookup</span>
<span class="sd">        (``dict``). Within distance lookup (``dict``) keys are the two</span>
<span class="sd">        incident vertices of the arc and values are distance to each of</span>
<span class="sd">        those arcs.</span>
<span class="sd">    </span>
<span class="sd">    snapped_coordinates : dict</span>
<span class="sd">        Keys are the point ids (``int``). Values are the snapped x,y</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    </span>
<span class="sd">    snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PointPattern.__init__"><a class="viewcode-back" href="../../generated/spaghetti.PointPattern.html#spaghetti.PointPattern.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># initialize points dictionary and counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># flag for points from a shapefile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">from_shp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">from_shp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># either set native point id from dataset or create new ids</span>
        <span class="k">if</span> <span class="n">idvariable</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">get_ids</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">idvariable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># extract the point geometries</span>
        <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">in_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pts_objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cg</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">Point</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pts_objs</span><span class="p">]</span>

        <span class="c1"># fetch attributes if requested</span>
        <span class="k">if</span> <span class="n">attribute</span><span class="p">:</span>

            <span class="c1"># open the database file if data is from shapefile</span>
            <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
                <span class="n">dbname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">in_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.dbf&quot;</span>
                <span class="n">db</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>

            <span class="c1"># if data is from a GeoDataFrame, drop the geometry column</span>
            <span class="c1"># and declare attribute values as a list of lists</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">in_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">db</span> <span class="o">=</span> <span class="p">[[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">db</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># iterate over all points</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>

            <span class="c1"># ids, attributes</span>
            <span class="k">if</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">db</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>

            <span class="c1"># ids, no attributes</span>
            <span class="k">elif</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

            <span class="c1"># no ids, attributes</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">db</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>

            <span class="c1"># no ids, no attributes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># close the shapefile and database file</span>
        <span class="c1"># if the input data is a .shp</span>
        <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
            <span class="n">pts</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">db</span><span class="p">:</span>
                <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># record number of points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="SimulatedPointPattern"><a class="viewcode-back" href="../../generated/spaghetti.SimulatedPointPattern.html#spaghetti.SimulatedPointPattern">[docs]</a><span class="k">class</span> <span class="nc">SimulatedPointPattern</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Struct style class to mirror the ``PointPattern`` class. If the</span>
<span class="sd">    ``PointPattern`` class has methods, it might make sense to make this</span>
<span class="sd">    a child of that class. This class is not intended to be used by the</span>
<span class="sd">    external user.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    npoints : int</span>
<span class="sd">        The number of points.</span>
<span class="sd">    </span>
<span class="sd">    obs_to_arc : dict</span>
<span class="sd">        Keys are arc ids (tuple). Values are snapped point information</span>
<span class="sd">        (``dict``).  Within the snapped point information (``dict``)</span>
<span class="sd">        keys are observation ids (``int``), and values are snapped</span>
<span class="sd">        coordinates.</span>
<span class="sd">    </span>
<span class="sd">    obs_to_vertex : list</span>
<span class="sd">       List of incident network vertices to snapped observation points</span>
<span class="sd">       converted from a ``default_dict``. Originally in the form of</span>
<span class="sd">       paired left/right nearest network vertices {netvtx1: obs_id1,</span>
<span class="sd">       netvtx2: obs_id1, netvtx1: obs_id2... netvtx1: obs_idn}, then</span>
<span class="sd">       simplified to a list in the form</span>
<span class="sd">       [netvtx1, netvtx2, netvtx1, netvtx2, ...].</span>
<span class="sd">       </span>
<span class="sd">    dist_to_vertex : dict</span>
<span class="sd">        Keys are observations ids (``int``). Values are distance lookup</span>
<span class="sd">        (``dict``). Within distance lookup (``dict``) keys are the two</span>
<span class="sd">        incident vertices of the arc and values are distance to each of</span>
<span class="sd">        those arcs.</span>
<span class="sd">    </span>
<span class="sd">    snapped_coordinates : dict</span>
<span class="sd">        Keys are the point ids (``int``). Values are the snapped x,y</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    </span>
<span class="sd">    snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimulatedPointPattern.__init__"><a class="viewcode-back" href="../../generated/spaghetti.SimulatedPointPattern.html#spaghetti.SimulatedPointPattern.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># duplicate post-snapping PointPattern class structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_to_arc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapped_coordinates</span> <span class="o">=</span> <span class="p">{}</span></div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>